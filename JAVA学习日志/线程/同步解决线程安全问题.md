# 快捷try catch   ctrl+alt+t
# 方法一：同步代码块
### synchronized(同步监视器）          
### {需要被同步的代码}
#### 1. 操作共享数据的代码，即为需要被同步的代码              -->不能包含代码多了，也不能包含代码少了
#### 2. 共享数据： 多个线程共同操作的变量。
#### 3. 同步监视器俗称 ’锁‘，任何一个类的对象都可以充当锁
#### 要求： 多个线程必须要共用同一把锁
#### 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器
****
# 方法二： 同步方法

### 1. 同步方法仍然涉及到同步监视器，只是不需要我们显示的声明
### 2. 非静态的同步方法，同步监视器是：this
## 静态的同步方法，同步监视器是：当前类本身

# 方法三： Lock锁







****
# 同步的方式，解决了线程的安全问题。
# 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低

****
# synchronized与Lock的异同
## 相同： 二者都可以解决线程安全问题
## 不同： synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器
##             Lock需要手动的启动同步（lock（）），同时结束同步也需要手动的实现（unlock（））
## 用synchronized比较多
# 优先使用顺序
## 优先考虑用lock，其次同步代码块，最后同步方法